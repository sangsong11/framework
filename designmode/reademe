strategy.cpp 策略模式：  将每个算法封装起来，让它们可以相互替换。换句话说，策略模式通常把一系列算法 封装到一系列具体策略类中来作为抽象策略类的子类，然后根据实际需要使用这些子类。
//策略类中的三种角色
//a)Context（环境类）：该类中维持着一个对抽象策略类的指针或引用。这里指Fighter类。
//b)Stategy（抽象策略类）：定义所支持的算法的公共接口，是所有策略类的父类。这里指ItemStrategy类。
//c)ConcreteStrategy（具体策略类）：抽象策略类的子类，实现抽象策略类中声明的接口。这里指ItemStrategy_BXD、ItemStrategy_DHD、ItemStrategy_SHD。
--------------------------------------------------------------------------------------------------------------------------------------
//策略类的优点：
//a)以扩展的方式支持对未来的变化，符合开闭原则。
//遇到大量不稳定的if条件分支 或者switch分支，就要优先考虑是否可以通过策略模式来解决。策略模式是if，switch条件分支的杀手。
//b)算法可以被复用。
//c)策略模式可以看成是类继承的一种替代方案。通过为环境类对象指定不同的策略，就可以改变环境类对象的行为。
//策略类的缺点：
//a)导致引入许多新策略类；
//b)使用策略时，调用者（main主函数）必须熟知所有策略类的功能并根据实际需要自行决定使用哪个策略类。


Observer.cpp 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会自动得到通知。
//观察者模式的四种角色
//a)Subject（主题）：观察目标，这里指Notifier类。
//b)ConcreteSubject（具体主题）：这里指TalkNotifier类。
//c)Observer（观察者）：这里指Fighter类。
//d)ConcreteObserver(具体观察者）：这里指F_Warrior和F_Mage子类。
--------------------------------------------------------------------------------------------------------------------------------------
//观察者模式的特点：
//a)在观察者和观察目标之间建立了一个抽象的耦合
//b)观察目标会向观察者列表中的所有观察者发送通知。
//c)可以通过增加代码来增加新的观察者或者观察目标，符合开闭原则
//（3）应用联想
//a)救援家族成员镖车
//b)将新闻推荐给符合其胃口的读者
//c)通过改变自身绘制的图形来真实的反应公司的销售数据。
//d)炮楼只会对30米内的玩家（列表内玩家）进行攻击。


builder.cpp 建造者模式：构建器/构建者/生成器模式-创建型模式  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
//建造者模式包含四种角色：
//a)Builder（抽象构建器）：这里指MonsterBuilder。
//b)ConcreteBuilder（具体构建器）：这里指M_UndeadBuilder、M_ElementBuilder、M_MechanicBuilder类。
//c)Product(产品）：这里指M_Undead、M_Element、M_Mechanic类。
//d)Director（指挥者）：MonsterDirector类。
//复杂的东西就考虑拆解，简单的东西就考虑合并。
-----------------------------------------------------------------------------------------------------
//另一个建造者模式的范例
//各部门员工 工作日报：标题、内容主体、结尾 三部分。
//a)标题部分：部门名称、日报生成日期等信息
//b)内容主体：具体描述可能有多条（一天可能做了多项工作）
//c)结尾：姓名
//将日报导出成多种格式的文件，比如纯文本，XML格式，JSON格式。
//（3.1）不用设计模式时程序应该如何书写
//导出到文件的三个步骤不变：a)拼接标题； b)拼接内容主体；c)拼接结尾
//考虑把这三个步骤（复杂对象的构建过程）提炼（抽象）出来，形成一个通用的处理过程。
//建造者模式的初衷：将构建不同格式数据的细节实现代码与具体的构建步骤 分离 达到复用 构建步骤的目的。
//何时使用：
//a)产品对象内部结构复杂，产品往往由多个零件组成。
//b)需要创建的产品对象内部属性互相依赖，需要指定创建次序。
//c)当创建复杂对象的步骤（过程）应该独立于该对象的组成部分；
//d)将复杂对象的创建和使用分离，使相同的创建过程可以创建不同的产品。
//指挥者类作用：
//a)通过部件以指定的顺序来构建整个产品（控制了构建过程）
//b)通过提供Construct接口隔离了客户端与具体构建过程所必须要调用的类的成员函数之间的关联。
//建造者模式优点：
//a)产品构建和产品表现上的分离。构建算法可以被复用。
//b)向客户端隐藏了产品内部的表现。
//c)产品的实现可以被随时替换。
//建造者模式缺点：
//a)要求所创建的产品有比较多的共同点，创建步骤（组成部分）要大致相同。
//b)该模式涉及到很多类。Director,Builder对象。对于理解和学习具有一定门槛。


